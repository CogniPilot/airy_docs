{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Airy Alicanto An Alicanto is a bird from Chilean mythology known to eat gold or silver and then glow. The bird is incapable of flight after overindulging on ore. Airy Alicanto represents the origin of CogniPilot's light weight, and minimalistic software stack following a correct by construction software paradigm. Correct by Construction Design Drivers CogniPilot is not aiming to re-invent an opensource autopilot that can be a drop in replacement for use in Hobby drones, FPV Racing drones, or a wide variety of DIY autonomous vehicles, there are many great autopilots for that ( ArduPilot , BetaFlight , PX4 ). CogniPilot instead focuses on state-of-the-art methologies for creating an autopilot with mathematically provable robustness properties. In order to achieve this level of reliability, accurate mathematical models of the vehicle and control software must be established that are beyond the expected domain of many hobbyists. However, for those willing to pursue the extra steps to create a mathematical model of their vehicle, templates are available to enable out of tree custom vehicles. CogniPilot is a new class of open source autopilot that can conduct safety critical missions such as transporting people, with a level of safety assurance not currently available in other open source autopilots. Minimum Viable Code for the Mission : By minimizing the lines of source code and branching, CogniPilot ensures higher reliability, maintainability, and verifiability of the project. Minimize Branch Statements in Control and Estimation Code : CogniPilot generally classifies its code components into two areas. The first is low-level driver and application code. The second is guidance, control, and estimation code for the vehicle. Developers carefully consider the addition of each branch (if statement etc.) in the code for the estimator and controller, as developers are modelling the entire system mathematically. Each branch statement considerably complicates the verification task. Minimize Maintenance to Maintain Reliability : A goal of CogniPilot is to support a wide variety of vehicles (Planes, Copters, Boats, Rovers, Submersibles) and user applications while maintaining software integrity and reliaiblity. CogniPilot plans to limit official support for each release to a minimal amount of vehicles for each class, while providing out of tree support via templates. Deprecate if No-longer Maintained : On each release cycle, the CogniPilot technical steering committee (TSC) will make a decision on whether to maintain official support for each vehicle platform or whether to adopt a new platform. This is to combat the slow creep in lines of code due to vehicle specific edge cases. Software Stack Ubuntu 22.04 Zephyr RTOS 3.5 ROS 2 Humble Gazebo Garden Currently supported platforms Rover B3RB ELM4 Get started To get started follow the guide on how to install on a computer . CogniPilot's next release To still be named, but going by B-Mythical (a mythical creature with a name starting with B) will have planned additional support for: Mulirotor NXP RDDrone TBD Submersible TBD Plane TBD","title":"Home"},{"location":"#about-airy-alicanto","text":"An Alicanto is a bird from Chilean mythology known to eat gold or silver and then glow. The bird is incapable of flight after overindulging on ore. Airy Alicanto represents the origin of CogniPilot's light weight, and minimalistic software stack following a correct by construction software paradigm.","title":"About Airy Alicanto"},{"location":"#correct-by-construction-design-drivers","text":"CogniPilot is not aiming to re-invent an opensource autopilot that can be a drop in replacement for use in Hobby drones, FPV Racing drones, or a wide variety of DIY autonomous vehicles, there are many great autopilots for that ( ArduPilot , BetaFlight , PX4 ). CogniPilot instead focuses on state-of-the-art methologies for creating an autopilot with mathematically provable robustness properties. In order to achieve this level of reliability, accurate mathematical models of the vehicle and control software must be established that are beyond the expected domain of many hobbyists. However, for those willing to pursue the extra steps to create a mathematical model of their vehicle, templates are available to enable out of tree custom vehicles. CogniPilot is a new class of open source autopilot that can conduct safety critical missions such as transporting people, with a level of safety assurance not currently available in other open source autopilots. Minimum Viable Code for the Mission : By minimizing the lines of source code and branching, CogniPilot ensures higher reliability, maintainability, and verifiability of the project. Minimize Branch Statements in Control and Estimation Code : CogniPilot generally classifies its code components into two areas. The first is low-level driver and application code. The second is guidance, control, and estimation code for the vehicle. Developers carefully consider the addition of each branch (if statement etc.) in the code for the estimator and controller, as developers are modelling the entire system mathematically. Each branch statement considerably complicates the verification task. Minimize Maintenance to Maintain Reliability : A goal of CogniPilot is to support a wide variety of vehicles (Planes, Copters, Boats, Rovers, Submersibles) and user applications while maintaining software integrity and reliaiblity. CogniPilot plans to limit official support for each release to a minimal amount of vehicles for each class, while providing out of tree support via templates. Deprecate if No-longer Maintained : On each release cycle, the CogniPilot technical steering committee (TSC) will make a decision on whether to maintain official support for each vehicle platform or whether to adopt a new platform. This is to combat the slow creep in lines of code due to vehicle specific edge cases.","title":"Correct by Construction Design Drivers"},{"location":"#software-stack","text":"Ubuntu 22.04 Zephyr RTOS 3.5 ROS 2 Humble Gazebo Garden","title":"Software Stack"},{"location":"#currently-supported-platforms","text":"","title":"Currently supported platforms"},{"location":"#rover","text":"B3RB ELM4","title":"Rover"},{"location":"#get-started","text":"To get started follow the guide on how to install on a computer .","title":"Get started"},{"location":"#cognipilots-next-release","text":"To still be named, but going by B-Mythical (a mythical creature with a name starting with B) will have planned additional support for:","title":"CogniPilot's next release"},{"location":"#mulirotor","text":"NXP RDDrone TBD","title":"Mulirotor"},{"location":"#submersible","text":"TBD","title":"Submersible"},{"location":"#plane","text":"TBD","title":"Plane"},{"location":"cerebri/about/","text":"About Cerebri Cerebri is a correct by construction autopilot. This software paradigm simplifies the verifcation and validation task through the consideration of ease of verification during code creation. The verification approach relies on the faithful synthesis of mathematical control laws for a given vehicle dynamic model interacting with a finite state machine. A layered approach is used to ensure robustness of the sytem. Layers of Verificaiton and Validation MISRA C compliance. Follow closely the industry best practices as defined in the MISRA C standard. The verification of the high levels of system operation use the low level operating system and drivers as a foundation. On top of the the solid operating system and drivers, create control and estimation methods that interact with a given dynamic model. For interested readers, see this paper of one such robust control strategy. ZROS Publish and Subscribe Library After considering both the rclc library and ZBUS , it was determined to be advantageous to construct a tailored publish/subscribe library for use in Cerebri. Comparison to Other Libraries Library Thread-safe Misra C Community Base Separate Read/Write Locks Lines of Code rclc no no large N/A ~29k ZBUS yes yes small no 1409 ZROS yes yes new library yes 748 While Cerebri was initially built around ZBUS, it was found too limiting due to the available topic listener and subscriber implementations. Instead of providing callback functions where the topic data structure is in context, ZROS signals the subscribers that a new message is availabe. It is then up to the subscriber to process the data. This is similar to a ZBUS subscriber, but it uses signals instead of message queues. In ZROS, it is imperative that the latest sensor data is available to each node, but skipping packets between nodes is acceptable. All messages describing the state of the vehicle are stateful, so dropping one message is not critical. This is also the goal for all input to the system. It should be assuemd that packets will be lost, and the requests of the user should be a state that is continually sent at a periodic rate. Cerebri is constructed using a set of reusable nodes. These nodes communicate using topics. ZROS is thread-safe and leverages a read semaphore and a write mutex lock on each topic. This allows multiple subscribers to read the data simultaneously. General Structure In order to simplify the verification process, the vehicle management firmware is divided into various subcomponents. Operating Systeam : Cerebri leverages the Zephyr RTOS, which is working towards MISRA C compliance . drivers : The drivers are low level operating system code to talk with various sensors, actuators etc. Drivers are primarily maintained in upstream Zephyr. lib : The libraries in Cerebri are divided into application specific folders. The libraries are typically reusable modules that may be incorporated into an application. They interface the low level drivers with the ZROS library. actuate : Deals with actuating motors, servos, sound, lights etc. core : Common application code and system workqueues. dream : Simulation specific modules. sense : Interfaces sensor drivers with the ZROS module synapse : Communicaiton based modules app : The application folder is where the vehicle finite state machine, control, and estimation code reside. By tailoring these components to a specific vehicle and use case it makes it more flexible for users to adapt and it also makes the verification tasks simpler as there is less code dealing with generalizations and abstractions to allow reuse on multiple vehicles. This structure allows for focus on the applications specific code for verification and validation. The state machine of the B3RB for example is written so that it can be easily adapted for model checking . The algorithms in Cyecca can also be analyzed with a dynamic model of the system to provide the mechanisms for hybrid model checking.","title":"About"},{"location":"cerebri/about/#about-cerebri","text":"Cerebri is a correct by construction autopilot. This software paradigm simplifies the verifcation and validation task through the consideration of ease of verification during code creation. The verification approach relies on the faithful synthesis of mathematical control laws for a given vehicle dynamic model interacting with a finite state machine. A layered approach is used to ensure robustness of the sytem.","title":"About Cerebri"},{"location":"cerebri/about/#layers-of-verificaiton-and-validation","text":"MISRA C compliance. Follow closely the industry best practices as defined in the MISRA C standard. The verification of the high levels of system operation use the low level operating system and drivers as a foundation. On top of the the solid operating system and drivers, create control and estimation methods that interact with a given dynamic model. For interested readers, see this paper of one such robust control strategy.","title":"Layers of Verificaiton and Validation"},{"location":"cerebri/about/#zros-publish-and-subscribe-library","text":"After considering both the rclc library and ZBUS , it was determined to be advantageous to construct a tailored publish/subscribe library for use in Cerebri.","title":"ZROS Publish and Subscribe Library"},{"location":"cerebri/about/#comparison-to-other-libraries","text":"Library Thread-safe Misra C Community Base Separate Read/Write Locks Lines of Code rclc no no large N/A ~29k ZBUS yes yes small no 1409 ZROS yes yes new library yes 748 While Cerebri was initially built around ZBUS, it was found too limiting due to the available topic listener and subscriber implementations. Instead of providing callback functions where the topic data structure is in context, ZROS signals the subscribers that a new message is availabe. It is then up to the subscriber to process the data. This is similar to a ZBUS subscriber, but it uses signals instead of message queues. In ZROS, it is imperative that the latest sensor data is available to each node, but skipping packets between nodes is acceptable. All messages describing the state of the vehicle are stateful, so dropping one message is not critical. This is also the goal for all input to the system. It should be assuemd that packets will be lost, and the requests of the user should be a state that is continually sent at a periodic rate. Cerebri is constructed using a set of reusable nodes. These nodes communicate using topics. ZROS is thread-safe and leverages a read semaphore and a write mutex lock on each topic. This allows multiple subscribers to read the data simultaneously.","title":"Comparison to Other Libraries"},{"location":"cerebri/about/#general-structure","text":"In order to simplify the verification process, the vehicle management firmware is divided into various subcomponents. Operating Systeam : Cerebri leverages the Zephyr RTOS, which is working towards MISRA C compliance . drivers : The drivers are low level operating system code to talk with various sensors, actuators etc. Drivers are primarily maintained in upstream Zephyr. lib : The libraries in Cerebri are divided into application specific folders. The libraries are typically reusable modules that may be incorporated into an application. They interface the low level drivers with the ZROS library. actuate : Deals with actuating motors, servos, sound, lights etc. core : Common application code and system workqueues. dream : Simulation specific modules. sense : Interfaces sensor drivers with the ZROS module synapse : Communicaiton based modules app : The application folder is where the vehicle finite state machine, control, and estimation code reside. By tailoring these components to a specific vehicle and use case it makes it more flexible for users to adapt and it also makes the verification tasks simpler as there is less code dealing with generalizations and abstractions to allow reuse on multiple vehicles. This structure allows for focus on the applications specific code for verification and validation. The state machine of the B3RB for example is written so that it can be easily adapted for model checking . The algorithms in Cyecca can also be analyzed with a dynamic model of the system to provide the mechanisms for hybrid model checking.","title":"General Structure"},{"location":"cerebri/boards/nxp_mr_canhubk3/","text":"NXP MR CANHUBK3 More documentation coming soon. NXP documentation","title":"NXP\u00ae MR CANHUBK3"},{"location":"cerebri/boards/nxp_mr_canhubk3/#nxp-mr-canhubk3","text":"More documentation coming soon. NXP documentation","title":"NXP MR CANHUBK3"},{"location":"cerebri/boards/nxp_vmu_rt1170/","text":"NXP VMU RT1170 Overview More documentation coming soon. Board schematics","title":"NXP\u00ae VMU RT1170"},{"location":"cerebri/boards/nxp_vmu_rt1170/#nxp-vmu-rt1170-overview","text":"More documentation coming soon. Board schematics","title":"NXP VMU RT1170 Overview"},{"location":"cerebri/platforms/rovers/","text":"Rovers Overview","title":"Rovers"},{"location":"cerebri/platforms/rovers/#rovers-overview","text":"","title":"Rovers Overview"},{"location":"cranium/about/","text":"About Cranium","title":"About"},{"location":"cranium/about/#about-cranium","text":"","title":"About Cranium"},{"location":"cranium/compute/navqplus/setup/","text":"NavQPlus set up for CogniPilot with ROS 2 Humble Looking for instructions on how to also install on a development computer? Click here to get instructions on how to setup and configure a development computer. Already previously followed all the steps to flash and configure the image on the NavQPlus and want to jump to installing CogniPilot on it? Click here to jump to installing CogniPilot on NavQPlus. About this guide These directions are written for someone with experience with embedded Linux and basic embedded computers. Step-by-step overview Download the pre-built latest image with Ubuntu 1 22.04 and ROS 2 3 Humble, exact instructions for that release image are included on the release documentation to use in conjunction with this guide. Extract the image navqplus-image-<version>.wic from the compressed downloaded file navqplus-image-<version>.wic.zstd and flash it to the EMMC , exact copy and paste instructions are on the release page. Log in for the first time by connecting to another computer using the USB to UART adatper , ethernet adapter or centermost (USB 2) USB-C\u00ae port . 2 Configure WiFi, System User Name and Password. Connect to NavQPlus over WiFi Install CogniPilot by running the included installer script. Flashing the eMMC To flash the eMMC on the NavQPlus use the uuu tool as part of the downloadable assests from the release. Once uuu has downloaded make sure to set it as executable. Make uuu executable: chmod a+x uuu find the boot switches on the NavQPlus and flip them to the \"Flash\" mode. Then, connect NavQPlus to the computer with the downloaded release using the leftmost (USB 1) USB-C\u00ae port and the two flash status lights should light up. Flash eMMC hookup and status lights. Make sure that the NavQPlus is recognized by uuu . Check if uuu sees NavQPlus: ./uuu -lsusb Found device with uuu. If it shows that a device is connected, continue to flashing. To flash the board, use the general command below or copy and paste the specific command from the release. Use uuu to flash eMMC with image: sudo ./uuu -b emmc_all navqplus-image-<version>.bin-flash_evk navqplus-image-<version>.wic Once this process has finished, make sure that the flash was successfull. If so, configure the boot switches to boot from eMMC. Successful eMMC flash. uuu gave a weird output abort message after flashing, did it work correctly? There is a know issue where uuu will throw an assertion failed error as seen below, however, the image is flashed correctly and the remaining steps setup and install steps can be followed. Boot Switches NavQPlus can be configured to boot from either SD card or eMMC. It also has a flash mode that allows for to flashing either the eMMC or SD card over USB-C\u00ae. See the table below for the boot switch configuration. Note we suggest to only flash and run from eMMC and leave the SD card for external storage. Mode Switch 1 Switch 2 SD ON ON eMMC OFF ON Flash ON OFF Log in for the first time Power on the NavQPlus by plugging in a USB-C\u00ae cable to the centermost (USB 2) USB-C\u00ae port or the 5 pin JST-GH power port if not powering over the centermost (USB 2) USB-C\u00ae port. NavQPlus will boot, and dispaly that it is fully booted with the status LEDs on board. The 3 LEDs by the USB1 port should be on, as well as two LEDs next to the CAN bus connectors. To log into NavQPlus, choose between using the included USB to UART adapter , Industrial Ethernet , or USB-C\u00ae with gadget ethernet mode . The default username/password combo is as follows: Username: user Password: user USB to UART adapter Connect the included USB to UART adapter to the UART2 port on the NavQPlus, and open a serial console application with a baud rate of 115200 8N1. Press enter if there is no output on the screen to get a log-in prompt. Use screen to connect over USB to UART: screen /dev/ttyUSB< #> 115200 How to close cleanly out of screen . To exit screen cleanly when done press simultaneously Ctrl Shift A followed by typing k then y . Ethernet Connect the included IX Industrial Ethernet cable to NavQPlus, and connect the RJ45 connector to another computer, switch, or router on the local network. Log into NavQPlus over SSH. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network. USB-C\u00ae Gadget Ethernet The IP address of the usb0 network interface on NavQPlus is statically assigned to 192.168.186.3. To use the USB-C\u00ae gadget ethernet to connect to the NavQPlus, assign a static IP on the connecting computers existing gadget ethernet interface. The network configuration is as follows: IP Address: 192.168.186.2 Network Mask: 255.255.255.0 Adding the network configuration to Network Manager. Once USB-C\u00ae gadget ethernet interface is set up on the connected computer, connect over SSH. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network. Configuring WiFi, System Hostname, Username or Password Configuring WiFi on NavQPlus To connect NavQPlus to a WiFi network, use the nmcli command. The interface is relatively straightforward, to connect with nmcli . Connect NavQPlus to WiFi using nmcli: sudo nmcli device wifi connect <network_name> password \"<password>\" If struggling to connect to a network, see if the network is visible. Check WiFi networks visible to the NavQPlus: sudo nmcli device wifi list Once connected to the WiFi network the NavQPlus will continue to connect to that network even after a reboot. What WiFi network is the NavQPlus currently connected to? To see what WiFi network the NavQPlus is currently connected to run previous command without sudo . Check current WiFi network NavQPlus is connected to: nmcli device wifi list Or if running with sudo it will be the network preceeded with a star. OPTIONAL - Configuring System Hostname, Username or Password Optionally, to change the default hostname, username, or password, see below. Change Hostname Change the hostname: hostnamectl set-hostname <new_hostname> Change Username Danger Changing the username can be dangerous and possibly result in a broken system state requiring a re-flash. Change the username: usermod -l <new_username> user mv /home/user /home/<new_username> Change Password Change the password: passwd Connecting to NavQPlus over WiFi Once setup to connect over a local WiFi network, SSH into the NavQPlus. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network. Install CogniPilot through included script Included in the image is an installation script that auto-updates when run. Before running make sure that the NavQPlus is connected to the internet on a network that allows it to download from github and Ubuntu servers. In the home directory there is a simple helper script that downloads and runs the latest CogniPilot NavQPlus installer . Cloning with ssh keys: If you want to use SSH keys with github on the NavQPlus you must first add or create them on the device. Otherwise you will need to answer n when asked to clone using already setup github ssh keys. Install CogniPilot on NavQPlus: ./install_cognipilot.sh When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop. When prompted to choose whether or not to optimize runtime performance: It is reccomended to select y for runtime optimization when prompted. When prompted to choose a release: airy for a stable non-development release. main for active development. When prompted to choose a platform to build: b3rb is an ackermann based mobile robotic platform. elm4 is a differential drive based mobile robotic platform. Does CycloneDDS need configuring? The NavQPlus Ubuntu 22.04 with ROS 2 Humble image uses CycloneDDS by default. Make sure to edit the default CycloneDDSConfig.xml to only allow the networks that are desired to connector over when trying to get maximal performance. An example of this is using only the WiFi device mlan0 to connect to a ROS 2 Domain. To save performance remove the other default included interfaces eth1 and usb0 by deleting those lines from the NavQPlus local ~/CycloneDDSconfig.xml . Ubuntu is a registered trademark of Canonical Ltd. \u21a9 USB-C\u00ae is a trademark of USB Implementers Forum. \u21a9 ROS 2 is governed by Open Robotics. \u21a9","title":"Setup"},{"location":"cranium/compute/navqplus/setup/#navqplus-set-up-for-cognipilot-with-ros-2-humble","text":"Looking for instructions on how to also install on a development computer? Click here to get instructions on how to setup and configure a development computer. Already previously followed all the steps to flash and configure the image on the NavQPlus and want to jump to installing CogniPilot on it? Click here to jump to installing CogniPilot on NavQPlus. About this guide These directions are written for someone with experience with embedded Linux and basic embedded computers.","title":"NavQPlus set up for CogniPilot with ROS 2 Humble"},{"location":"cranium/compute/navqplus/setup/#step-by-step-overview","text":"Download the pre-built latest image with Ubuntu 1 22.04 and ROS 2 3 Humble, exact instructions for that release image are included on the release documentation to use in conjunction with this guide. Extract the image navqplus-image-<version>.wic from the compressed downloaded file navqplus-image-<version>.wic.zstd and flash it to the EMMC , exact copy and paste instructions are on the release page. Log in for the first time by connecting to another computer using the USB to UART adatper , ethernet adapter or centermost (USB 2) USB-C\u00ae port . 2 Configure WiFi, System User Name and Password. Connect to NavQPlus over WiFi Install CogniPilot by running the included installer script.","title":"Step-by-step overview"},{"location":"cranium/compute/navqplus/setup/#flashing-the-emmc","text":"To flash the eMMC on the NavQPlus use the uuu tool as part of the downloadable assests from the release. Once uuu has downloaded make sure to set it as executable. Make uuu executable: chmod a+x uuu find the boot switches on the NavQPlus and flip them to the \"Flash\" mode. Then, connect NavQPlus to the computer with the downloaded release using the leftmost (USB 1) USB-C\u00ae port and the two flash status lights should light up. Flash eMMC hookup and status lights. Make sure that the NavQPlus is recognized by uuu . Check if uuu sees NavQPlus: ./uuu -lsusb Found device with uuu. If it shows that a device is connected, continue to flashing. To flash the board, use the general command below or copy and paste the specific command from the release. Use uuu to flash eMMC with image: sudo ./uuu -b emmc_all navqplus-image-<version>.bin-flash_evk navqplus-image-<version>.wic Once this process has finished, make sure that the flash was successfull. If so, configure the boot switches to boot from eMMC. Successful eMMC flash. uuu gave a weird output abort message after flashing, did it work correctly? There is a know issue where uuu will throw an assertion failed error as seen below, however, the image is flashed correctly and the remaining steps setup and install steps can be followed.","title":"Flashing the eMMC"},{"location":"cranium/compute/navqplus/setup/#boot-switches","text":"NavQPlus can be configured to boot from either SD card or eMMC. It also has a flash mode that allows for to flashing either the eMMC or SD card over USB-C\u00ae. See the table below for the boot switch configuration. Note we suggest to only flash and run from eMMC and leave the SD card for external storage. Mode Switch 1 Switch 2 SD ON ON eMMC OFF ON Flash ON OFF","title":"Boot Switches"},{"location":"cranium/compute/navqplus/setup/#log-in-for-the-first-time","text":"Power on the NavQPlus by plugging in a USB-C\u00ae cable to the centermost (USB 2) USB-C\u00ae port or the 5 pin JST-GH power port if not powering over the centermost (USB 2) USB-C\u00ae port. NavQPlus will boot, and dispaly that it is fully booted with the status LEDs on board. The 3 LEDs by the USB1 port should be on, as well as two LEDs next to the CAN bus connectors. To log into NavQPlus, choose between using the included USB to UART adapter , Industrial Ethernet , or USB-C\u00ae with gadget ethernet mode . The default username/password combo is as follows: Username: user Password: user","title":"Log in for the first time"},{"location":"cranium/compute/navqplus/setup/#usb-to-uart-adapter","text":"Connect the included USB to UART adapter to the UART2 port on the NavQPlus, and open a serial console application with a baud rate of 115200 8N1. Press enter if there is no output on the screen to get a log-in prompt. Use screen to connect over USB to UART: screen /dev/ttyUSB< #> 115200 How to close cleanly out of screen . To exit screen cleanly when done press simultaneously Ctrl Shift A followed by typing k then y .","title":"USB to UART adapter"},{"location":"cranium/compute/navqplus/setup/#ethernet","text":"Connect the included IX Industrial Ethernet cable to NavQPlus, and connect the RJ45 connector to another computer, switch, or router on the local network. Log into NavQPlus over SSH. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.","title":"Ethernet"},{"location":"cranium/compute/navqplus/setup/#usb-c-gadget-ethernet","text":"The IP address of the usb0 network interface on NavQPlus is statically assigned to 192.168.186.3. To use the USB-C\u00ae gadget ethernet to connect to the NavQPlus, assign a static IP on the connecting computers existing gadget ethernet interface. The network configuration is as follows: IP Address: 192.168.186.2 Network Mask: 255.255.255.0 Adding the network configuration to Network Manager. Once USB-C\u00ae gadget ethernet interface is set up on the connected computer, connect over SSH. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.","title":"USB-C\u00ae Gadget Ethernet"},{"location":"cranium/compute/navqplus/setup/#configuring-wifi-system-hostname-username-or-password","text":"","title":"Configuring WiFi, System Hostname, Username or Password"},{"location":"cranium/compute/navqplus/setup/#configuring-wifi-on-navqplus","text":"To connect NavQPlus to a WiFi network, use the nmcli command. The interface is relatively straightforward, to connect with nmcli . Connect NavQPlus to WiFi using nmcli: sudo nmcli device wifi connect <network_name> password \"<password>\" If struggling to connect to a network, see if the network is visible. Check WiFi networks visible to the NavQPlus: sudo nmcli device wifi list Once connected to the WiFi network the NavQPlus will continue to connect to that network even after a reboot. What WiFi network is the NavQPlus currently connected to? To see what WiFi network the NavQPlus is currently connected to run previous command without sudo . Check current WiFi network NavQPlus is connected to: nmcli device wifi list Or if running with sudo it will be the network preceeded with a star.","title":"Configuring WiFi on NavQPlus"},{"location":"cranium/compute/navqplus/setup/#optional-configuring-system-hostname-username-or-password","text":"Optionally, to change the default hostname, username, or password, see below.","title":"OPTIONAL - Configuring System Hostname, Username or Password"},{"location":"cranium/compute/navqplus/setup/#change-hostname","text":"Change the hostname: hostnamectl set-hostname <new_hostname>","title":"Change Hostname"},{"location":"cranium/compute/navqplus/setup/#change-username","text":"Danger Changing the username can be dangerous and possibly result in a broken system state requiring a re-flash. Change the username: usermod -l <new_username> user mv /home/user /home/<new_username>","title":"Change Username"},{"location":"cranium/compute/navqplus/setup/#change-password","text":"Change the password: passwd","title":"Change Password"},{"location":"cranium/compute/navqplus/setup/#connecting-to-navqplus-over-wifi","text":"Once setup to connect over a local WiFi network, SSH into the NavQPlus. Connect to NavQPlus over ssh: ssh <username>@<hostname>.local Another way to connect to NavQPlus over ssh depending on network setup: ssh <username>@<hostname> Changing hostname Default hostname is imx8mpnavq . The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.","title":"Connecting to NavQPlus over WiFi"},{"location":"cranium/compute/navqplus/setup/#install-cognipilot-through-included-script","text":"Included in the image is an installation script that auto-updates when run. Before running make sure that the NavQPlus is connected to the internet on a network that allows it to download from github and Ubuntu servers. In the home directory there is a simple helper script that downloads and runs the latest CogniPilot NavQPlus installer . Cloning with ssh keys: If you want to use SSH keys with github on the NavQPlus you must first add or create them on the device. Otherwise you will need to answer n when asked to clone using already setup github ssh keys. Install CogniPilot on NavQPlus: ./install_cognipilot.sh When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop. When prompted to choose whether or not to optimize runtime performance: It is reccomended to select y for runtime optimization when prompted. When prompted to choose a release: airy for a stable non-development release. main for active development. When prompted to choose a platform to build: b3rb is an ackermann based mobile robotic platform. elm4 is a differential drive based mobile robotic platform. Does CycloneDDS need configuring? The NavQPlus Ubuntu 22.04 with ROS 2 Humble image uses CycloneDDS by default. Make sure to edit the default CycloneDDSConfig.xml to only allow the networks that are desired to connector over when trying to get maximal performance. An example of this is using only the WiFi device mlan0 to connect to a ROS 2 Domain. To save performance remove the other default included interfaces eth1 and usb0 by deleting those lines from the NavQPlus local ~/CycloneDDSconfig.xml . Ubuntu is a registered trademark of Canonical Ltd. \u21a9 USB-C\u00ae is a trademark of USB Implementers Forum. \u21a9 ROS 2 is governed by Open Robotics. \u21a9","title":"Install CogniPilot through included script"},{"location":"cranium/corti/corti/","text":"Corti Overview","title":"Corti"},{"location":"cranium/corti/corti/#corti-overview","text":"","title":"Corti Overview"},{"location":"cranium/synapse/synapse/","text":"Synapse Overview","title":"Synapse"},{"location":"cranium/synapse/synapse/#synapse-overview","text":"","title":"Synapse Overview"},{"location":"dream/worlds/worlds/","text":"Dream Worlds Overview Run the desired simulated world in gazebo garden by appending world:=<desired-world-name> to the simulation launch script. Depot World To use depot world append world:=depot to the simulation launch script. Depot world is a highly graphics intensive world that simulates a small warehouse. Basic Map World To use basic map world append world:=basic_map to the simulation launch script. Basic map world is very minimalistic to help users on less capable machines. How do I add a different world? It is very easy to add other worlds to dream for use in simulation, there are only a few things to keep in mind: Make sure the desired model assets work correctly in Gazebo Garden (this includes checking the SDF version) Add the worlds model assets to dream_world/models/<model name> Create a unique named world sdf file in dream_world/worlds/ Make sure the world name stays as default so the sensors can be properly mapped through the ros_gz bridge. Add all the sensor plugins and required world defaults . Include the desired model . Append the worlds unique file name (without .sdf) to the simulation launch script.","title":"Worlds"},{"location":"dream/worlds/worlds/#dream-worlds-overview","text":"Run the desired simulated world in gazebo garden by appending world:=<desired-world-name> to the simulation launch script.","title":"Dream Worlds Overview"},{"location":"dream/worlds/worlds/#depot-world","text":"To use depot world append world:=depot to the simulation launch script. Depot world is a highly graphics intensive world that simulates a small warehouse.","title":"Depot World"},{"location":"dream/worlds/worlds/#basic-map-world","text":"To use basic map world append world:=basic_map to the simulation launch script. Basic map world is very minimalistic to help users on less capable machines. How do I add a different world? It is very easy to add other worlds to dream for use in simulation, there are only a few things to keep in mind: Make sure the desired model assets work correctly in Gazebo Garden (this includes checking the SDF version) Add the worlds model assets to dream_world/models/<model name> Create a unique named world sdf file in dream_world/worlds/ Make sure the world name stays as default so the sensors can be properly mapped through the ros_gz bridge. Add all the sensor plugins and required world defaults . Include the desired model . Append the worlds unique file name (without .sdf) to the simulation launch script.","title":"Basic Map World"},{"location":"electrode/about/","text":"About Electrode","title":"About"},{"location":"electrode/about/#about-electrode","text":"","title":"About Electrode"},{"location":"electrode/foxglove/","text":"Foxglove Overview","title":"Foxglove"},{"location":"electrode/foxglove/#foxglove-overview","text":"","title":"Foxglove Overview"},{"location":"electrode/rviz2/","text":"RVIZ 2 Overview","title":"RVIZ 2"},{"location":"electrode/rviz2/#rviz-2-overview","text":"","title":"RVIZ 2 Overview"},{"location":"getting_started/install/","text":"Installation for development computer Looking for instructions on how to also install on a NavQPlus? Click here to get instructions on how to setup and configure a NavQPlus . Continue this guide for installing CogniPilot on a native development computer. Requirements Ubuntu 22.04 host environment. Stable internet connection for downloading and installing packages. This may work on other environments but only Ubuntu 22.04 is officially supported. Optional before installing Setup SSH keys on host and GitHub If planning to develop and make changes to code it is suggested to set up ssh keys, however, it is not strictly required to do so. Ensure that ssh keys are setup on host computer and GitHub to be able to clone the CogniPilot repositories with ssh. Setup GPG keys on host and GitHub Optionally setup gpg keys on host computer and GitHub to sign commits. Use CogniPilot universal installer Using Docker instead. If preffering to use docker, there is a Docker Development Container that may be used instead. To install CogniPilot on a system download the universal installer and run it ( follow the prompts in the installer ). Download and run the universal installer: sudo apt-get update sudo apt-get install git wget -y mkdir -p ~/cognipilot/installer wget -O ~/cognipilot/installer/install_cognipilot.sh https://raw.githubusercontent.com/CogniPilot/helmet/main/install/install_cognipilot.sh chmod a+x ~/cognipilot/installer/install_cognipilot.sh /bin/bash ~/cognipilot/installer/install_cognipilot.sh When prompted to choose a release: airy for a stable non-development release. main for active development. When prompted to choose installer type select 1 for native : native select this for installing on development computer navqplus only if installing on a NavQPlus image that does not already have the installer on it. Click here for the proper way to install on a NavQPlus. When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop. Build the workspace The build_workspace script: Sets up the workspaces using vcs and yaml files provided in helmet . Builds Cranium ROS 2 workspace. Builds Cerebri (Zephyr RTOS native_sim) for software-in-the-loop simulation. Builds Cyecca (control/estimation software). Builds Electrode ROS 2 workspace (ground station software). Build the CogniPilot workspace with build_workspace script ( follow the prompts in the workspace builder ). Run the build_workspace script: build_workspace When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop. When prompted to choose a platform to build: b3rb is an ackermann based mobile robotic platform with simulation. elm4 is a differential drive based mobile robotic platform with simulation. Platforms Currently supported platforms in this release are B3RB and ELM4. Using a real platform: B3RB hardware guide. ELM4 hardware guide coming soon. Simulating a platform: B3RB simulation guide. ELM4 simulation guide coming soon. Convenience Scripts docs script The docs script: Downloads and builds the documentation repositories for the documentation currently being read so that contributions can be made easily. Allows for selection of documents to be served with mkdocs. To view the docs offline locally or to contribute to them use the docs convenience script ( follow the prompts for the correct docs ). Run the docs convenience script: docs When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best if contributing to the documentation but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to contribute and only want a local viewer. When prompted to choose a doc to build: airy is the airy developers guide site (airy.cognipilot.org) . overview is the release overview site (cognipilot.org) . I ran the command where are the docs? Click here to access the locally built docs on 0.0.0.0:8000 cyecca script The cyecca script: Starts a JupyterLab instance for Cyecca to aid in developing control and estimation algorithms. To develop algorithms with cyecca use the cyecca convenience script. Run the cyeccs convenience script: cyecca","title":"Getting Started"},{"location":"getting_started/install/#installation-for-development-computer","text":"Looking for instructions on how to also install on a NavQPlus? Click here to get instructions on how to setup and configure a NavQPlus . Continue this guide for installing CogniPilot on a native development computer.","title":"Installation for development computer"},{"location":"getting_started/install/#requirements","text":"Ubuntu 22.04 host environment. Stable internet connection for downloading and installing packages. This may work on other environments but only Ubuntu 22.04 is officially supported.","title":"Requirements"},{"location":"getting_started/install/#optional-before-installing","text":"","title":"Optional before installing"},{"location":"getting_started/install/#setup-ssh-keys-on-host-and-github","text":"If planning to develop and make changes to code it is suggested to set up ssh keys, however, it is not strictly required to do so. Ensure that ssh keys are setup on host computer and GitHub to be able to clone the CogniPilot repositories with ssh.","title":"Setup SSH keys on host and GitHub"},{"location":"getting_started/install/#setup-gpg-keys-on-host-and-github","text":"Optionally setup gpg keys on host computer and GitHub to sign commits.","title":"Setup GPG keys on host and GitHub"},{"location":"getting_started/install/#use-cognipilot-universal-installer","text":"Using Docker instead. If preffering to use docker, there is a Docker Development Container that may be used instead. To install CogniPilot on a system download the universal installer and run it ( follow the prompts in the installer ). Download and run the universal installer: sudo apt-get update sudo apt-get install git wget -y mkdir -p ~/cognipilot/installer wget -O ~/cognipilot/installer/install_cognipilot.sh https://raw.githubusercontent.com/CogniPilot/helmet/main/install/install_cognipilot.sh chmod a+x ~/cognipilot/installer/install_cognipilot.sh /bin/bash ~/cognipilot/installer/install_cognipilot.sh When prompted to choose a release: airy for a stable non-development release. main for active development. When prompted to choose installer type select 1 for native : native select this for installing on development computer navqplus only if installing on a NavQPlus image that does not already have the installer on it. Click here for the proper way to install on a NavQPlus. When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop.","title":"Use CogniPilot universal installer"},{"location":"getting_started/install/#build-the-workspace","text":"The build_workspace script: Sets up the workspaces using vcs and yaml files provided in helmet . Builds Cranium ROS 2 workspace. Builds Cerebri (Zephyr RTOS native_sim) for software-in-the-loop simulation. Builds Cyecca (control/estimation software). Builds Electrode ROS 2 workspace (ground station software). Build the CogniPilot workspace with build_workspace script ( follow the prompts in the workspace builder ). Run the build_workspace script: build_workspace When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best for development work but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to make modifications or develop. When prompted to choose a platform to build: b3rb is an ackermann based mobile robotic platform with simulation. elm4 is a differential drive based mobile robotic platform with simulation.","title":"Build the workspace"},{"location":"getting_started/install/#platforms","text":"Currently supported platforms in this release are B3RB and ELM4.","title":"Platforms"},{"location":"getting_started/install/#using-a-real-platform","text":"B3RB hardware guide. ELM4 hardware guide coming soon.","title":"Using a real platform:"},{"location":"getting_started/install/#simulating-a-platform","text":"B3RB simulation guide. ELM4 simulation guide coming soon.","title":"Simulating a platform:"},{"location":"getting_started/install/#convenience-scripts","text":"","title":"Convenience Scripts"},{"location":"getting_started/install/#docs-script","text":"The docs script: Downloads and builds the documentation repositories for the documentation currently being read so that contributions can be made easily. Allows for selection of documents to be served with mkdocs. To view the docs offline locally or to contribute to them use the docs convenience script ( follow the prompts for the correct docs ). Run the docs convenience script: docs When prompted to choose whether or not to use ssh-keys: y to clone with ssh keys , best if contributing to the documentation but only select if ssh keys are already present and setup with GitHub. n to clone with https, best for users who do not plan to contribute and only want a local viewer. When prompted to choose a doc to build: airy is the airy developers guide site (airy.cognipilot.org) . overview is the release overview site (cognipilot.org) . I ran the command where are the docs? Click here to access the locally built docs on 0.0.0.0:8000","title":"docs script"},{"location":"getting_started/install/#cyecca-script","text":"The cyecca script: Starts a JupyterLab instance for Cyecca to aid in developing control and estimation algorithms. To develop algorithms with cyecca use the cyecca convenience script. Run the cyeccs convenience script: cyecca","title":"cyecca script"},{"location":"getting_started/advanced/docker/","text":"Docker If you wish, there is a development docker container ( docker hub , docker source ) for CogniPilot with Nvidia GPU support. If you use this option, do not run the native_install script, as the packages are already installed. Dependencies You must install the latest official docker. Install Docker Tip Don't forget Linux Post Install Clone Docker Repository On the Host mkdir -p ~/cognipilot cd ~/cognipilot git clone https://github.com/cognipilot/docker cd ~/cognipilot/docker git submodule update --init --recursive Start the Docker Image The dream start command, automatically pulls the dream image from dockerhub, and starts the image. On the Host cd ~/cognipilot/docker/dream ./dream start Execute a Command on the Docker Image This starts a shell within the container. On the Host ./dream exec If passed extra arguments will run those commands as well. Convenience Scripts (Docker Specific) unlock This command executes the script docs . Unlocks GPG and SSH keys mounted in the docker image. Within the Container unlock See the other non-docker specific scripts in the main installation Build the Docker Image (For Advanced Users) This process will take awhile. It is usually sufficient to use dream start instead, which will automatically pull the latest image from dockerhub. On the Host cd ~/cognipilot/docker/dream ./dream build","title":"Docker"},{"location":"getting_started/advanced/docker/#docker","text":"If you wish, there is a development docker container ( docker hub , docker source ) for CogniPilot with Nvidia GPU support. If you use this option, do not run the native_install script, as the packages are already installed.","title":"Docker"},{"location":"getting_started/advanced/docker/#dependencies","text":"You must install the latest official docker. Install Docker Tip Don't forget Linux Post Install","title":"Dependencies"},{"location":"getting_started/advanced/docker/#clone-docker-repository","text":"On the Host mkdir -p ~/cognipilot cd ~/cognipilot git clone https://github.com/cognipilot/docker cd ~/cognipilot/docker git submodule update --init --recursive","title":"Clone Docker Repository"},{"location":"getting_started/advanced/docker/#start-the-docker-image","text":"The dream start command, automatically pulls the dream image from dockerhub, and starts the image. On the Host cd ~/cognipilot/docker/dream ./dream start","title":"Start the Docker Image"},{"location":"getting_started/advanced/docker/#execute-a-command-on-the-docker-image","text":"This starts a shell within the container. On the Host ./dream exec If passed extra arguments will run those commands as well.","title":"Execute a Command on the Docker Image"},{"location":"getting_started/advanced/docker/#convenience-scripts-docker-specific","text":"","title":"Convenience Scripts (Docker Specific)"},{"location":"getting_started/advanced/docker/#unlock","text":"This command executes the script docs . Unlocks GPG and SSH keys mounted in the docker image. Within the Container unlock See the other non-docker specific scripts in the main installation","title":"unlock"},{"location":"getting_started/advanced/docker/#build-the-docker-image-for-advanced-users","text":"This process will take awhile. It is usually sufficient to use dream start instead, which will automatically pull the latest image from dockerhub. On the Host cd ~/cognipilot/docker/dream ./dream build","title":"Build the Docker Image (For Advanced Users)"},{"location":"helmet/about/","text":"Helmet Overview","title":"About"},{"location":"helmet/about/#helmet-overview","text":"","title":"Helmet Overview"},{"location":"reference_systems/b3rb/about/","text":"B3RB Platform Overview Example of Navigation","title":"About"},{"location":"reference_systems/b3rb/about/#b3rb-platform-overview","text":"","title":"B3RB Platform Overview"},{"location":"reference_systems/b3rb/about/#example-of-navigation","text":"","title":"Example of Navigation"},{"location":"reference_systems/b3rb/electrode/","text":"B3RB Electrode Overview It is highly recommended to use a dedicated controller with Electrode. Any compatible ROS 2 Joy input device will work, an example of a Logitech F310 to control vehicle modes. Joy Input device Electrode requires a compatible Joy input device to properly run. Any compatible Joy input can be used to control the platform. Selecting a Mode The modes are mapped to the Joy input message buttons. Arming START : arm BACK : disarm Example of using with a Logitech F310 A - manual X - cmd_vel (nav2) B - auto (other cmd_vel) Y - calibration Manual Mode: Left stick Up/Down: throttle Right stick Left/Right: steering Nav2 (cmd_vel) Mode: Click 2D Pose Goal and select desired location on map.","title":"Using with Electrode"},{"location":"reference_systems/b3rb/electrode/#b3rb-electrode-overview","text":"It is highly recommended to use a dedicated controller with Electrode. Any compatible ROS 2 Joy input device will work, an example of a Logitech F310 to control vehicle modes.","title":"B3RB Electrode Overview"},{"location":"reference_systems/b3rb/electrode/#joy-input-device","text":"Electrode requires a compatible Joy input device to properly run. Any compatible Joy input can be used to control the platform.","title":"Joy Input device"},{"location":"reference_systems/b3rb/electrode/#selecting-a-mode","text":"The modes are mapped to the Joy input message buttons.","title":"Selecting a Mode"},{"location":"reference_systems/b3rb/electrode/#arming","text":"START : arm BACK : disarm","title":"Arming"},{"location":"reference_systems/b3rb/electrode/#example-of-using-with-a-logitech-f310","text":"A - manual X - cmd_vel (nav2) B - auto (other cmd_vel) Y - calibration","title":"Example of using with a Logitech F310"},{"location":"reference_systems/b3rb/electrode/#manual-mode","text":"Left stick Up/Down: throttle Right stick Left/Right: steering","title":"Manual Mode:"},{"location":"reference_systems/b3rb/electrode/#nav2-cmd_vel-mode","text":"Click 2D Pose Goal and select desired location on map.","title":"Nav2 (cmd_vel) Mode:"},{"location":"reference_systems/b3rb/hardware/","text":"B3RB Hardware Overview","title":"Hardware Overview"},{"location":"reference_systems/b3rb/hardware/#b3rb-hardware-overview","text":"","title":"B3RB Hardware Overview"},{"location":"reference_systems/b3rb/operate/","text":"B3RB Operation Overview","title":"Operating the platform"},{"location":"reference_systems/b3rb/operate/#b3rb-operation-overview","text":"","title":"B3RB Operation Overview"},{"location":"reference_systems/b3rb/setup/","text":"B3RB Setup","title":"Setting up the System"},{"location":"reference_systems/b3rb/setup/#b3rb-setup","text":"","title":"B3RB Setup"},{"location":"reference_systems/b3rb/simulation/","text":"B3RB Simulation Simulation uses gazebo garden to simulate sensors and physics in the \"dream\" worlds that connects to Cerebri running ontop Zephyr RTOS native_sim . Before running simulation Before running the simulation for the first time make sure to have first followed the installation for development computer guide . Once at building the workspace make sure to select 1. b3rb for the platform. This will also build Cerebri for native_sim so the section below \"Build Cerebri for native_sim \" can be skipped if the build_workspace script was just run. If other images have been built in Cerebri since running the script make sure to follow \"Build Cerebri for native_sim \" . Build Cerebri for native_sim To build Cerebri for native_sim (posix) make sure the Zephyr RTOS build environment is up to date and that at some point previously the build_workspace script was run for b3rb . If the build_workspace script was just run, the steps in this section can be skipped. This section only needs to be run if different images have been built in Cerebri since having run the build_workspace script. Update Zephyr RTOS build environment with west: cd ~/cognipilot/ws/cerebri git pull west update Build the Cerebri for native_sim and install it so it can be found. Build and install Cerebri for native_sim: west build -b native_sim app/b3rb/ -p -t install Run Electrode If using the foxglove backend for Electrode. Make sure to have first run the build_foxglove script at some point and follow the prompts . Run build_foxglove script: build_foxglove To visualize and control navigation run Electrode with the preffered backend set , the default and reccomended is foxglove. Run Electrode with the foxglove backend for simulation. Electrode for simulation with foxglove: ros2 launch electrode electrode.launch.py sim: = true Foxglove studio opened, how do I connect it to the simulation? After launching electrode with only passing sim:=true connect to it on ws://localhost:8765 My foxglove studio connected but it's not showing what I would expect it to, how do I load the b3rb layout? Click the LAYOUT drop down in upper right followed by Imoport from file... Select the b3rb.json followed by pressing Open by navigating Home > cognipilot > electrode > src > electrode > foxglove_layouts > b3rb.json The layout should now be present regardless of foxglove being connected to a websocket data source. Example of depot world simulation with electrode running foxglove. Optionally run Electrode with the RVIZ 2 backend for simulation. Electrode can be optionally run with the RVIZ 2 backend for simulation, however, it requires a physical joystick device for input. Electrode for simulation with RVIZ 2: ros2 launch electrode electrode.launch.py rviz2: = true sim: = true Example of depot world simulation with electrode running rviz2. Run B3RB SIL The default dream world for B3RB is the basic map world . Launch simulation with basic map world: ros2 launch b3rb_gz_bringup sil.launch.py My ROS 2 cerebri_bringup node is showing an error and is keeping simulation from running. If the simulation launch script is throwing an error about cerebri_bringup make sure that cerebri is built, installed and sourced properly for native_sim . If running on a machine with a powerful graphics card optionally run the more gaphics intensive depot world . Launch simulation with depot world: ros2 launch b3rb_gz_bringup sil.launch.py world: = depot Video example of using the simulation Example of using simulation with electrode running foxglove.","title":"Running in Simulation"},{"location":"reference_systems/b3rb/simulation/#b3rb-simulation","text":"Simulation uses gazebo garden to simulate sensors and physics in the \"dream\" worlds that connects to Cerebri running ontop Zephyr RTOS native_sim .","title":"B3RB Simulation"},{"location":"reference_systems/b3rb/simulation/#before-running-simulation","text":"Before running the simulation for the first time make sure to have first followed the installation for development computer guide . Once at building the workspace make sure to select 1. b3rb for the platform. This will also build Cerebri for native_sim so the section below \"Build Cerebri for native_sim \" can be skipped if the build_workspace script was just run. If other images have been built in Cerebri since running the script make sure to follow \"Build Cerebri for native_sim \" .","title":"Before running simulation"},{"location":"reference_systems/b3rb/simulation/#build-cerebri-for-native_sim","text":"To build Cerebri for native_sim (posix) make sure the Zephyr RTOS build environment is up to date and that at some point previously the build_workspace script was run for b3rb . If the build_workspace script was just run, the steps in this section can be skipped. This section only needs to be run if different images have been built in Cerebri since having run the build_workspace script. Update Zephyr RTOS build environment with west: cd ~/cognipilot/ws/cerebri git pull west update Build the Cerebri for native_sim and install it so it can be found. Build and install Cerebri for native_sim: west build -b native_sim app/b3rb/ -p -t install","title":"Build Cerebri for native_sim"},{"location":"reference_systems/b3rb/simulation/#run-electrode","text":"If using the foxglove backend for Electrode. Make sure to have first run the build_foxglove script at some point and follow the prompts . Run build_foxglove script: build_foxglove To visualize and control navigation run Electrode with the preffered backend set , the default and reccomended is foxglove.","title":"Run Electrode"},{"location":"reference_systems/b3rb/simulation/#run-electrode-with-the-foxglove-backend-for-simulation","text":"Electrode for simulation with foxglove: ros2 launch electrode electrode.launch.py sim: = true Foxglove studio opened, how do I connect it to the simulation? After launching electrode with only passing sim:=true connect to it on ws://localhost:8765 My foxglove studio connected but it's not showing what I would expect it to, how do I load the b3rb layout? Click the LAYOUT drop down in upper right followed by Imoport from file... Select the b3rb.json followed by pressing Open by navigating Home > cognipilot > electrode > src > electrode > foxglove_layouts > b3rb.json The layout should now be present regardless of foxglove being connected to a websocket data source. Example of depot world simulation with electrode running foxglove.","title":"Run Electrode with the foxglove backend for simulation."},{"location":"reference_systems/b3rb/simulation/#optionally-run-electrode-with-the-rviz-2-backend-for-simulation","text":"Electrode can be optionally run with the RVIZ 2 backend for simulation, however, it requires a physical joystick device for input. Electrode for simulation with RVIZ 2: ros2 launch electrode electrode.launch.py rviz2: = true sim: = true Example of depot world simulation with electrode running rviz2.","title":"Optionally run Electrode with the RVIZ 2 backend for simulation."},{"location":"reference_systems/b3rb/simulation/#run-b3rb-sil","text":"The default dream world for B3RB is the basic map world . Launch simulation with basic map world: ros2 launch b3rb_gz_bringup sil.launch.py My ROS 2 cerebri_bringup node is showing an error and is keeping simulation from running. If the simulation launch script is throwing an error about cerebri_bringup make sure that cerebri is built, installed and sourced properly for native_sim . If running on a machine with a powerful graphics card optionally run the more gaphics intensive depot world . Launch simulation with depot world: ros2 launch b3rb_gz_bringup sil.launch.py world: = depot","title":"Run B3RB SIL"},{"location":"reference_systems/b3rb/simulation/#video-example-of-using-the-simulation","text":"Example of using simulation with electrode running foxglove.","title":"Video example of using the simulation"},{"location":"reference_systems/b3rb/status/","text":"B3RB Status Lighting and Sounds Status Lights The tailights on the B3RB are used for showing the current system status and breathe to show the system is alive. My status lights are not breathing, what's wrong? If the status lights are not breathing and there is a startup sound check your board for: LED connection to SPI2 port on MR CANHUBK3 . cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_B3RB_LIGHTING=y cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_ACTUATE_LED_ARRAY=y cerebri/app/b3rb/boards/mr_canhubk3.conf setting for CONFIG_LED_STRIP=y CONFIG_APA102_STRIP=y If the status lights are not breathing and there is no startup sound it can be a sign there was a potential power event that occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout: Check all wiring is plugged in correctly. Power off the board. Remove the jumper JP1 (pins 1-2 open), which is connected by default. Power on the board. Reconnect the jumper JP1 (pins 1-2 shorted). Startup Lights [ ] [ ] Startup breathing light pattern [Safety On, Disarm, Mode Unknown]. Safety Lights Safety On Lights [ ] [ ] The outer set of lights are green when the Safety is On . Safety Off Lights [ ] [ ] The outer set of lights are red when the Safety is Off . Arming and Critical Fuel Lights Disarmed Lights [ ] [ ] The middle set of lights are green when Disarmed . Armed Lights [ ] [ ] The middle set of lights are red when Armed . Fuel Critical Lights [ ] [ ] The middle set of lights are yellow when Fuel is Critical . Mode Lights Mode Unknown Lights [ ] [ ] The inner set of lights are white when Mode Unknown . Mode Manual Lights [ ] [ ] The inner set of lights are green when Mode Manual . Mode CMD_VEL Lights [ ] [ ] The inner set of lights are blue when Mode CMD_VEL . Mode Calibration Lights [ ] [ ] The inner set of lights are yellow when Mode Calibration . Status Sounds These sounds allow for audio based system diagnosis. Startup Sound Flight of the Alicanto Flight of the Alicanto startup sound signifies the system has booted. I plugged power in but didn't hear the sound, what's wrong? If the status lights are breathing but there is no sound check your board setup for: Proper ADAP board revision (Rev C). Buzzer connection to GPS port on ADAP. prj.conf setting for CONFIG_CEREBRI_ACTUATE_SOUND=y If there is no startup sound when powered on and the status lights are not breathing there is a potential that a power event occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout: Check all wiring is plugged in correctly. Power off the board. Remove the jumper JP1 (pins 1-2 open), which is connected by default. Power on the board. Reconnect the jumper JP1 (pins 1-2 shorted). State Change Request Sounds Rejected State Change Request Low tone followed by mid-high-low-mid-high sinusoid. I keep hearing this rejection sound, what is causing it? The rejection sound comes from the Finite State Machine (FSM) rejecting a transition request by the request not passing the transition guards. More information about the request rejection can be seen in with: ros2 topic echo /cerebri/out/status Electrode below the fuel guage in the Foxglove layout. Mode Sounds Manual Sound Morse Code 1 for manual mode enum (. - - - -) CMD_VEL Sound Morse Code 3 for CMD_VEL mode enum (. . . - -) Calibration Sound Morse Code 4 for calibration mode enum (. . . . -) Safety Sounds Safety Off Sound Morse Code S increasing long octives (- - -) Safety On Sound Morse Code S decreasing long octives (- - -) Arming Sounds Arm Sound Morse Code A mid-high tone (. -) Disarm Sound Morse Code A mid-low tone (. -) Connection Loss Sounds Joy Input Loss Sound Morse Code E every 3 seconds ( . ) (sounds only after safety is off). Fuel Status Sounds Fuel Low Sound Morse Code EK every 10 seconds ( . - . - ) Fuel Critical Sound Morse Code EK continuous ( . - . - )","title":"Status Lighting and Sounds"},{"location":"reference_systems/b3rb/status/#b3rb-status-lighting-and-sounds","text":"","title":"B3RB Status Lighting and Sounds"},{"location":"reference_systems/b3rb/status/#status-lights","text":"The tailights on the B3RB are used for showing the current system status and breathe to show the system is alive. My status lights are not breathing, what's wrong? If the status lights are not breathing and there is a startup sound check your board for: LED connection to SPI2 port on MR CANHUBK3 . cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_B3RB_LIGHTING=y cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_ACTUATE_LED_ARRAY=y cerebri/app/b3rb/boards/mr_canhubk3.conf setting for CONFIG_LED_STRIP=y CONFIG_APA102_STRIP=y If the status lights are not breathing and there is no startup sound it can be a sign there was a potential power event that occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout: Check all wiring is plugged in correctly. Power off the board. Remove the jumper JP1 (pins 1-2 open), which is connected by default. Power on the board. Reconnect the jumper JP1 (pins 1-2 shorted).","title":"Status Lights"},{"location":"reference_systems/b3rb/status/#startup-lights","text":"[ ] [ ] Startup breathing light pattern [Safety On, Disarm, Mode Unknown].","title":"Startup Lights"},{"location":"reference_systems/b3rb/status/#safety-lights","text":"","title":"Safety Lights"},{"location":"reference_systems/b3rb/status/#safety-on-lights","text":"[ ] [ ] The outer set of lights are green when the Safety is On .","title":"Safety On Lights"},{"location":"reference_systems/b3rb/status/#safety-off-lights","text":"[ ] [ ] The outer set of lights are red when the Safety is Off .","title":"Safety Off Lights"},{"location":"reference_systems/b3rb/status/#arming-and-critical-fuel-lights","text":"","title":"Arming and Critical Fuel Lights"},{"location":"reference_systems/b3rb/status/#disarmed-lights","text":"[ ] [ ] The middle set of lights are green when Disarmed .","title":"Disarmed Lights"},{"location":"reference_systems/b3rb/status/#armed-lights","text":"[ ] [ ] The middle set of lights are red when Armed .","title":"Armed Lights"},{"location":"reference_systems/b3rb/status/#fuel-critical-lights","text":"[ ] [ ] The middle set of lights are yellow when Fuel is Critical .","title":"Fuel Critical Lights"},{"location":"reference_systems/b3rb/status/#mode-lights","text":"","title":"Mode Lights"},{"location":"reference_systems/b3rb/status/#mode-unknown-lights","text":"[ ] [ ] The inner set of lights are white when Mode Unknown .","title":"Mode Unknown Lights"},{"location":"reference_systems/b3rb/status/#mode-manual-lights","text":"[ ] [ ] The inner set of lights are green when Mode Manual .","title":"Mode Manual Lights"},{"location":"reference_systems/b3rb/status/#mode-cmd_vel-lights","text":"[ ] [ ] The inner set of lights are blue when Mode CMD_VEL .","title":"Mode CMD_VEL Lights"},{"location":"reference_systems/b3rb/status/#mode-calibration-lights","text":"[ ] [ ] The inner set of lights are yellow when Mode Calibration .","title":"Mode Calibration Lights"},{"location":"reference_systems/b3rb/status/#status-sounds","text":"These sounds allow for audio based system diagnosis.","title":"Status Sounds"},{"location":"reference_systems/b3rb/status/#startup-sound","text":"","title":"Startup Sound"},{"location":"reference_systems/b3rb/status/#flight-of-the-alicanto","text":"Flight of the Alicanto startup sound signifies the system has booted. I plugged power in but didn't hear the sound, what's wrong? If the status lights are breathing but there is no sound check your board setup for: Proper ADAP board revision (Rev C). Buzzer connection to GPS port on ADAP. prj.conf setting for CONFIG_CEREBRI_ACTUATE_SOUND=y If there is no startup sound when powered on and the status lights are not breathing there is a potential that a power event occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout: Check all wiring is plugged in correctly. Power off the board. Remove the jumper JP1 (pins 1-2 open), which is connected by default. Power on the board. Reconnect the jumper JP1 (pins 1-2 shorted).","title":"Flight of the Alicanto"},{"location":"reference_systems/b3rb/status/#state-change-request-sounds","text":"","title":"State Change Request Sounds"},{"location":"reference_systems/b3rb/status/#rejected-state-change-request","text":"Low tone followed by mid-high-low-mid-high sinusoid. I keep hearing this rejection sound, what is causing it? The rejection sound comes from the Finite State Machine (FSM) rejecting a transition request by the request not passing the transition guards. More information about the request rejection can be seen in with: ros2 topic echo /cerebri/out/status Electrode below the fuel guage in the Foxglove layout.","title":"Rejected State Change Request"},{"location":"reference_systems/b3rb/status/#mode-sounds","text":"","title":"Mode Sounds"},{"location":"reference_systems/b3rb/status/#manual-sound","text":"Morse Code 1 for manual mode enum (. - - - -)","title":"Manual Sound"},{"location":"reference_systems/b3rb/status/#cmd_vel-sound","text":"Morse Code 3 for CMD_VEL mode enum (. . . - -)","title":"CMD_VEL Sound"},{"location":"reference_systems/b3rb/status/#calibration-sound","text":"Morse Code 4 for calibration mode enum (. . . . -)","title":"Calibration Sound"},{"location":"reference_systems/b3rb/status/#safety-sounds","text":"","title":"Safety Sounds"},{"location":"reference_systems/b3rb/status/#safety-off-sound","text":"Morse Code S increasing long octives (- - -)","title":"Safety Off Sound"},{"location":"reference_systems/b3rb/status/#safety-on-sound","text":"Morse Code S decreasing long octives (- - -)","title":"Safety On Sound"},{"location":"reference_systems/b3rb/status/#arming-sounds","text":"","title":"Arming Sounds"},{"location":"reference_systems/b3rb/status/#arm-sound","text":"Morse Code A mid-high tone (. -)","title":"Arm Sound"},{"location":"reference_systems/b3rb/status/#disarm-sound","text":"Morse Code A mid-low tone (. -)","title":"Disarm Sound"},{"location":"reference_systems/b3rb/status/#connection-loss-sounds","text":"","title":"Connection Loss Sounds"},{"location":"reference_systems/b3rb/status/#joy-input-loss-sound","text":"Morse Code E every 3 seconds ( . ) (sounds only after safety is off).","title":"Joy Input Loss Sound"},{"location":"reference_systems/b3rb/status/#fuel-status-sounds","text":"","title":"Fuel Status Sounds"},{"location":"reference_systems/b3rb/status/#fuel-low-sound","text":"Morse Code EK every 10 seconds ( . - . - )","title":"Fuel Low Sound"},{"location":"reference_systems/b3rb/status/#fuel-critical-sound","text":"Morse Code EK continuous ( . - . - )","title":"Fuel Critical Sound"},{"location":"tools/cyecca/about/","text":"About Cyecca Cyecca is a control and estimation library. The library leverages Casadi based equation graphs and can be thought of the control and estimation equivalent of TensorFlow. The equation graph is used for automatic differentiation , a numerically efficient method for computing jacobians. Casadi's core is written in C, with Python and Matlab wrappers. Cyecca leverages the Python library in Casadi. Casadi allows the user to create advanced geometric algorithms without advanced knowledge of embedded programming. This provides a route for rapid development. B3RB Example For a complete example of how Cyecca may be used, the B3RB will be used as an example. Generation of Equations The proceeding leverages the Cyecca library to generate a simple rover estimator in 2D. Derive Rover Estimator: def derive_rover2d_estimator (): # define symbols x = ca . SX . sym ( \"x\" ) # x position in world frame of rear axle (north) y = ca . SX . sym ( \"y\" ) # y position in world frame of rear axle (east) theta = ca . SX . sym ( \"theta\" ) # angular heading in world frame (rotation about down) u = ca . SX . sym ( \"u\" ) # forward velocity, along body x omega = ca . SX . sym ( \"omega\" ) # angular velocity around z axis dt = ca . SX . sym ( \"dt\" ) # time stemp G = lie . SE2 X = G . elem ( ca . vertcat ( x , y , theta )) v = G . algebra . elem ( ca . vertcat ( u , 0 , omega )) X1 = X + v f_predict = ca . Function ( \"predict\" , [ X . param , omega , u ], [ X1 . param ], [ \"x0\" , \"omega\" , \"u\" ], [ \"x1\" ] ) eqs = { \"predict\" : f_predict } return eqs Here the relevant variables of interest are defined. Relevant variables of interest: # define symbols x = ca . SX . sym ( \"x\" ) # x position in world frame of rear axle (north) y = ca . SX . sym ( \"y\" ) # y position in world frame of rear axle (east) theta = ca . SX . sym ( \"theta\" ) # angular heading in world frame (rotation about down) u = ca . SX . sym ( \"u\" ) # forward velocity, along body x omega = ca . SX . sym ( \"omega\" ) # angular velocity around z axis dt = ca . SX . sym ( \"dt\" ) # time stemp SE2 Lie Algebra element: G = lie . SE2 # the SE2 Lie group which describes planar 2D motion X = G . elem ( ca . vertcat ( x , y , theta )) @ v = G . algebra . elem ( ca . vertcat ( u , 0 , omega )) The SE2 Lie Algebra element, which describes the rotational and linear movement of the rover u represents the distance travelled along the arc created with an angular change of omega these may be thought of at linear and angular velocity multiplied by time. X1 = X + v This represents the exact integration in SE(2), there are no numerical integration errors due to the geometric nature of the integration in the Lie Algebra, one may think of this as the Lie Group equivalent of: \\(x_1 = x_0 + u*dt\\) , where \\(x_0\\) is the initial state, \\(x_1\\) is the final state, \\(u\\) is the velocity, and \\(dt\\) is the change in time. f_predict = ca . Function ( \"predict\" , [ X . param , omega , u ], [ X1 . param ], [ \"x0\" , \"omega\" , \"u\" ], [ \"x1\" ] ) eqs = { \"predict\" : f_predict } return eqs Finally the casadi function routine is used to construct and return the prediction function. Code Generation Routines Generate code: def generate_code ( eqs : dict , filename , dest_dir : str , ** kwargs ): dest_dir = Path ( dest_dir ) dest_dir . mkdir ( exist_ok = True ) p = { \"verbose\" : True , \"mex\" : False , #(1) \"cpp\" : False , #(2) \"main\" : False , #(3) \"with_header\" : True , #(4) \"with_mem\" : False , #(5) \"with_export\" : False , #(6) \"with_import\" : False , \"include_math\" : True , #(7) \"avoid_stack\" : True , #(8) } for k , v in kwargs . items (): assert k in p . keys () p [ k ] = v gen = ca . CodeGenerator ( filename , p ) for name , eq in eqs . items (): gen . add ( eq ) gen . generate ( str ( dest_dir ) + os . se Without mex which is used for Matlab. Without cpp since Cerebri is focused on MISRA C . Without a main function, just use functions in a library. With a header for use in the libray. Without mem, as internal memory is not necessary for these routines. Without export, as there is no need for dll export. With math, as this leverages the math routines. With avoid_stack, so the data used for calculations is explicitly passed in and not allocated with the stack of the function. Generating Code if __name__ == \"__main__\" : #rover_plan() #plt.show() #test_bezier() print ( \"generating casadi equations\" ) # derivate casadi functions eqs = {} eqs . update ( derive_bezier6 ()) eqs . update ( derive_rover ()) eqs . update ( derive_se2 ()) eqs . update ( derive_rover2d_estimator ()) for name , eq in eqs . items (): print ( 'eq: ' , name ) generate_code ( eqs , filename = \"b3rb.c\" , dest_dir = \"gen\" ) print ( \"complete\" ) This routine generates from each of the relevant equation and creates the b3rb.c file. It is recommended to use poetry to run Cyecca, a working Poetry environment is provided with Cyecca. It is recommended to use this environment to generate the code. poetry run -C ~/cognipilot/tools/src/cyecca python3 b3rb.py Adding Casadi Generated Code to Apps Next add the generated source files to CMake . if ( CONFIG_CEREBRI_B3RB_CASADI ) list ( APPEND SOURCE_FILES src/casadi/gen/b3rb.c ) endif () Calling Casadi based function from Cerebri It is now straight forward to call the generated Casadi function from within Cerebri. The estimator app collects the necessary information by subscribing to the following topics: imu topic provides the required angular velocity data. wheel_odometry topic provides the required distance travelled. The estimator app publishes : estimator_odometry topic contains the location the robot believes it is at. The Casadi function call: /* predict:(x0[3],omega,u)->(x1[3]) */ { double delta_theta = omega * dt ; //(1) double x1 [ 3 ]; // LOG_DBG(\"predict\"); CASADI_FUNC_ARGS ( predict ); args [ 0 ] = ctx -> x ; //(2) args [ 1 ] = & delta_theta ; //(3) args [ 2 ] = & u ; //(4) res [ 0 ] = x1 ; //(5) CASADI_FUNC_CALL ( predict ); //(6) // update x, W handle_update ( ctx , x1 ); } Given the angular velocity \\(\\omega\\) from the z axis of the gyroscope, multiply the delta time \\(dt\\) since the last estimator run, and then compute the angular change \\(d\\theta\\) in radians. Load the function argument for initial state \\(x_0\\) into the Casadi function. Load the function argument for angular velocity \\(\\omega\\) into the Casadi function. Load the function argument for velocity \\(u\\) into the Casadi function. Set the result \\(x_1\\) in the res double array. The macro CASADI_FUNC_ARGS allocates the args, res, w (work), iw (integer work) vectors which are used in the function call. Here the signature is provided in the generated code The macros are defined here . #define CASADI\\_FUNC\\_ARGS(name) \\ casadi_int iw[name##_SZ_IW]; \\ casadi_real w[name##_SZ_W]; \\ const casadi_real* args[name##_SZ_ARG]; \\ casadi_real* res[name##_SZ_RES]; \\ int mem = 0; #define CASADI\\_FUNC\\_CALL(name) \\ name(args, res, iw, w, mem);","title":"Cyecca"},{"location":"tools/cyecca/about/#about-cyecca","text":"Cyecca is a control and estimation library. The library leverages Casadi based equation graphs and can be thought of the control and estimation equivalent of TensorFlow. The equation graph is used for automatic differentiation , a numerically efficient method for computing jacobians. Casadi's core is written in C, with Python and Matlab wrappers. Cyecca leverages the Python library in Casadi. Casadi allows the user to create advanced geometric algorithms without advanced knowledge of embedded programming. This provides a route for rapid development.","title":"About Cyecca"},{"location":"tools/cyecca/about/#b3rb-example","text":"For a complete example of how Cyecca may be used, the B3RB will be used as an example.","title":"B3RB Example"},{"location":"tools/cyecca/about/#generation-of-equations","text":"The proceeding leverages the Cyecca library to generate a simple rover estimator in 2D. Derive Rover Estimator: def derive_rover2d_estimator (): # define symbols x = ca . SX . sym ( \"x\" ) # x position in world frame of rear axle (north) y = ca . SX . sym ( \"y\" ) # y position in world frame of rear axle (east) theta = ca . SX . sym ( \"theta\" ) # angular heading in world frame (rotation about down) u = ca . SX . sym ( \"u\" ) # forward velocity, along body x omega = ca . SX . sym ( \"omega\" ) # angular velocity around z axis dt = ca . SX . sym ( \"dt\" ) # time stemp G = lie . SE2 X = G . elem ( ca . vertcat ( x , y , theta )) v = G . algebra . elem ( ca . vertcat ( u , 0 , omega )) X1 = X + v f_predict = ca . Function ( \"predict\" , [ X . param , omega , u ], [ X1 . param ], [ \"x0\" , \"omega\" , \"u\" ], [ \"x1\" ] ) eqs = { \"predict\" : f_predict } return eqs Here the relevant variables of interest are defined. Relevant variables of interest: # define symbols x = ca . SX . sym ( \"x\" ) # x position in world frame of rear axle (north) y = ca . SX . sym ( \"y\" ) # y position in world frame of rear axle (east) theta = ca . SX . sym ( \"theta\" ) # angular heading in world frame (rotation about down) u = ca . SX . sym ( \"u\" ) # forward velocity, along body x omega = ca . SX . sym ( \"omega\" ) # angular velocity around z axis dt = ca . SX . sym ( \"dt\" ) # time stemp SE2 Lie Algebra element: G = lie . SE2 # the SE2 Lie group which describes planar 2D motion X = G . elem ( ca . vertcat ( x , y , theta )) @ v = G . algebra . elem ( ca . vertcat ( u , 0 , omega )) The SE2 Lie Algebra element, which describes the rotational and linear movement of the rover u represents the distance travelled along the arc created with an angular change of omega these may be thought of at linear and angular velocity multiplied by time. X1 = X + v This represents the exact integration in SE(2), there are no numerical integration errors due to the geometric nature of the integration in the Lie Algebra, one may think of this as the Lie Group equivalent of: \\(x_1 = x_0 + u*dt\\) , where \\(x_0\\) is the initial state, \\(x_1\\) is the final state, \\(u\\) is the velocity, and \\(dt\\) is the change in time. f_predict = ca . Function ( \"predict\" , [ X . param , omega , u ], [ X1 . param ], [ \"x0\" , \"omega\" , \"u\" ], [ \"x1\" ] ) eqs = { \"predict\" : f_predict } return eqs Finally the casadi function routine is used to construct and return the prediction function.","title":"Generation of Equations"},{"location":"tools/cyecca/about/#code-generation-routines","text":"Generate code: def generate_code ( eqs : dict , filename , dest_dir : str , ** kwargs ): dest_dir = Path ( dest_dir ) dest_dir . mkdir ( exist_ok = True ) p = { \"verbose\" : True , \"mex\" : False , #(1) \"cpp\" : False , #(2) \"main\" : False , #(3) \"with_header\" : True , #(4) \"with_mem\" : False , #(5) \"with_export\" : False , #(6) \"with_import\" : False , \"include_math\" : True , #(7) \"avoid_stack\" : True , #(8) } for k , v in kwargs . items (): assert k in p . keys () p [ k ] = v gen = ca . CodeGenerator ( filename , p ) for name , eq in eqs . items (): gen . add ( eq ) gen . generate ( str ( dest_dir ) + os . se Without mex which is used for Matlab. Without cpp since Cerebri is focused on MISRA C . Without a main function, just use functions in a library. With a header for use in the libray. Without mem, as internal memory is not necessary for these routines. Without export, as there is no need for dll export. With math, as this leverages the math routines. With avoid_stack, so the data used for calculations is explicitly passed in and not allocated with the stack of the function.","title":"Code Generation Routines"},{"location":"tools/cyecca/about/#generating-code","text":"if __name__ == \"__main__\" : #rover_plan() #plt.show() #test_bezier() print ( \"generating casadi equations\" ) # derivate casadi functions eqs = {} eqs . update ( derive_bezier6 ()) eqs . update ( derive_rover ()) eqs . update ( derive_se2 ()) eqs . update ( derive_rover2d_estimator ()) for name , eq in eqs . items (): print ( 'eq: ' , name ) generate_code ( eqs , filename = \"b3rb.c\" , dest_dir = \"gen\" ) print ( \"complete\" ) This routine generates from each of the relevant equation and creates the b3rb.c file. It is recommended to use poetry to run Cyecca, a working Poetry environment is provided with Cyecca. It is recommended to use this environment to generate the code. poetry run -C ~/cognipilot/tools/src/cyecca python3 b3rb.py","title":"Generating Code"},{"location":"tools/cyecca/about/#adding-casadi-generated-code-to-apps","text":"Next add the generated source files to CMake . if ( CONFIG_CEREBRI_B3RB_CASADI ) list ( APPEND SOURCE_FILES src/casadi/gen/b3rb.c ) endif ()","title":"Adding Casadi Generated Code to Apps"},{"location":"tools/cyecca/about/#calling-casadi-based-function-from-cerebri","text":"It is now straight forward to call the generated Casadi function from within Cerebri. The estimator app collects the necessary information by subscribing to the following topics: imu topic provides the required angular velocity data. wheel_odometry topic provides the required distance travelled. The estimator app publishes : estimator_odometry topic contains the location the robot believes it is at. The Casadi function call: /* predict:(x0[3],omega,u)->(x1[3]) */ { double delta_theta = omega * dt ; //(1) double x1 [ 3 ]; // LOG_DBG(\"predict\"); CASADI_FUNC_ARGS ( predict ); args [ 0 ] = ctx -> x ; //(2) args [ 1 ] = & delta_theta ; //(3) args [ 2 ] = & u ; //(4) res [ 0 ] = x1 ; //(5) CASADI_FUNC_CALL ( predict ); //(6) // update x, W handle_update ( ctx , x1 ); } Given the angular velocity \\(\\omega\\) from the z axis of the gyroscope, multiply the delta time \\(dt\\) since the last estimator run, and then compute the angular change \\(d\\theta\\) in radians. Load the function argument for initial state \\(x_0\\) into the Casadi function. Load the function argument for angular velocity \\(\\omega\\) into the Casadi function. Load the function argument for velocity \\(u\\) into the Casadi function. Set the result \\(x_1\\) in the res double array. The macro CASADI_FUNC_ARGS allocates the args, res, w (work), iw (integer work) vectors which are used in the function call. Here the signature is provided in the generated code The macros are defined here . #define CASADI\\_FUNC\\_ARGS(name) \\ casadi_int iw[name##_SZ_IW]; \\ casadi_real w[name##_SZ_W]; \\ const casadi_real* args[name##_SZ_ARG]; \\ casadi_real* res[name##_SZ_RES]; \\ int mem = 0; #define CASADI\\_FUNC\\_CALL(name) \\ name(args, res, iw, w, mem);","title":"Calling Casadi based function from Cerebri"}]}